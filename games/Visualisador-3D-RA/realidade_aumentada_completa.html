<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Realidade Aumentada - Escala e Rota√ß√£o Din√¢micas</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #cameraFeed {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1); /* Espelhar a imagem da c√¢mera */
        }
        
        #threeCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
        }
        
        #loading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            z-index: 100;
            transition: opacity 0.5s;
        }
        
        #loading h1 {
            margin-bottom: 20px;
            font-size: 2rem;
            color: #4CAF50;
        }
        
        .spinner {
            border: 8px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top: 8px solid #4CAF50;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px;
            border-radius: 15px;
            max-width: 350px;
            z-index: 20;
            font-size: 14px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        
        #instructions h2 {
            margin-top: 0;
            color: #4CAF50;
            font-size: 18px;
        }
        
        #debugInfo {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px;
            border-radius: 10px;
            font-family: monospace;
            font-size: 12px;
            z-index: 20;
            max-width: 300px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        
        .status {
            margin-top: 10px;
            padding: 8px;
            border-radius: 5px;
            background: rgba(255, 255, 255, 0.1);
        }
        
        .status.success {
            color: #4CAF50;
            border-left: 3px solid #4CAF50;
        }
        
        .status.error {
            color: #f44336;
            border-left: 3px solid #f44336;
        }
    </style>
</head>
<body>
    <div id="container">
        <video id="cameraFeed" playsinline></video>
        <canvas id="threeCanvas"></canvas>
        
        <div id="loading">
            <div class="spinner"></div>
            <h1>Carregando Aplica√ß√£o</h1>
            <div id="loadingStatus">Inicializando...</div>
        </div>
        
        <div id="instructions">
            <h2>üéØ Rastreamento Completo:</h2>
            <p><strong>‚úÖ Escala Din√¢mica:</strong> O objeto fica menor quando sua m√£o est√° longe da c√¢mera</p>
            <p><strong>‚úÖ Rota√ß√£o 3D:</strong> O objeto rotaciona junto com sua m√£o em todas as dire√ß√µes</p>
            <p><strong>‚úÖ Posicionamento Perfeito:</strong> Aparece exatamente na palma da sua m√£o</p>
            <br>
            <p><em>Mova sua m√£o para perto/longe da c√¢mera para ver a escala din√¢mica. Rotacione sua m√£o para ver a rota√ß√£o 3D!</em></p>
        </div>
        
        <div id="debugInfo">
            <strong>Status da Detec√ß√£o:</strong><br>
            <span id="handStatus">M√£o: N√£o detectada</span><br><br>
            <strong>Posi√ß√£o:</strong><br>
            <span id="positionInfo">X: --, Y: --, Z: --</span><br><br>
            <strong>Rota√ß√£o:</strong><br>
            <span id="rotationInfo">RX: --, RY: --, RZ: --</span><br><br>
            <strong>Escala:</strong><br>
            <span id="scaleInfo">Tamanho: --</span><br><br>
            <strong>Confian√ßa:</strong><br>
            <span id="confidenceInfo">--</span>
        </div>
    </div>

    <!-- Bibliotecas necess√°rias -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    
    <!-- Arquivo do objeto 3D -->
    <script src="objeto3d.js"></script>
    
    <script>
        // Vari√°veis globais
        let scene, camera, renderer, objeto3D;
        let handDetected = false;
        let handPosition = { x: 0, y: 0, z: 0 };
        let handRotation = { x: 0, y: 0, z: 0 };
        let handScale = 1.0;
        let smoothingFactor = 0.75; // Suaviza√ß√£o para movimento fluido
        let rotationSmoothingFactor = 0.6; // Suaviza√ß√£o espec√≠fica para rota√ß√£o
        let scaleSmoothingFactor = 0.8; // Suaviza√ß√£o espec√≠fica para escala
        let videoWidth = 1280;
        let videoHeight = 720;

        // Elementos DOM
        const videoElement = document.getElementById('cameraFeed');
        const canvasElement = document.getElementById('threeCanvas');
        const loadingElement = document.getElementById('loading');
        const loadingStatus = document.getElementById('loadingStatus');
        const handStatus = document.getElementById('handStatus');
        const positionInfo = document.getElementById('positionInfo');
        const rotationInfo = document.getElementById('rotationInfo');
        const scaleInfo = document.getElementById('scaleInfo');
        const confidenceInfo = document.getElementById('confidenceInfo');

        // Atualizar status de carregamento
        function updateLoadingStatus(message, isError = false) {
            loadingStatus.textContent = message;
            loadingStatus.className = 'status ' + (isError ? 'error' : 'success');
        }

        // Converter coordenadas da m√£o para coordenadas 3D
        function convertHandToWorld(handX, handY, handZ) {
            // Inverter X devido ao espelhamento da c√¢mera
            const worldX = (0.5 - handX) * 8;
            const worldY = (0.5 - handY) * 6;
            const worldZ = handZ * -10;
            
            return { x: worldX, y: worldY, z: worldZ };
        }

        // Calcular tamanho da m√£o baseado na dist√¢ncia entre pontos espec√≠ficos
        function calculateHandSize(landmarks) {
            // Calcular dist√¢ncia entre pulso e ponta do dedo m√©dio
            const wrist = landmarks[0];
            const middleFingerTip = landmarks[12];
            
            const distance = Math.sqrt(
                Math.pow(middleFingerTip.x - wrist.x, 2) +
                Math.pow(middleFingerTip.y - wrist.y, 2) +
                Math.pow(middleFingerTip.z - wrist.z, 2)
            );
            
            // Normalizar e ajustar escala (valores t√≠picos entre 0.15 e 0.25)
            const normalizedSize = Math.max(0.1, Math.min(1.0, distance * 4));
            return normalizedSize;
        }

        // Calcular orienta√ß√£o 3D completa da m√£o
        function calculateHandOrientation(landmarks) {
            // Pontos de refer√™ncia para calcular orienta√ß√£o
            const wrist = landmarks[0];
            const middleFingerMCP = landmarks[9];
            const indexFingerMCP = landmarks[5];
            const pinkyMCP = landmarks[17];
            const thumbCMC = landmarks[1];
            
            // Vetor principal da palma (do pulso ao dedo m√©dio)
            const palmVector = {
                x: middleFingerMCP.x - wrist.x,
                y: middleFingerMCP.y - wrist.y,
                z: middleFingerMCP.z - wrist.z
            };
            
            // Vetor lateral (do mindinho ao indicador)
            const sideVector = {
                x: indexFingerMCP.x - pinkyMCP.x,
                y: indexFingerMCP.y - pinkyMCP.y,
                z: indexFingerMCP.z - pinkyMCP.z
            };
            
            // Vetor do polegar para calcular rota√ß√£o Z
            const thumbVector = {
                x: thumbCMC.x - wrist.x,
                y: thumbCMC.y - wrist.y,
                z: thumbCMC.z - wrist.z
            };
            
            // Calcular √¢ngulos de rota√ß√£o Euler
            // Rota√ß√£o X (inclina√ß√£o vertical da m√£o)
            const rotX = Math.atan2(palmVector.y, Math.sqrt(palmVector.x * palmVector.x + palmVector.z * palmVector.z));
            
            // Rota√ß√£o Y (rota√ß√£o lateral da m√£o)
            const rotY = Math.atan2(-palmVector.x, palmVector.z);
            
            // Rota√ß√£o Z (tor√ß√£o da m√£o)
            const rotZ = Math.atan2(sideVector.y, sideVector.x);
            
            return { 
                x: rotX * 1.5, // Amplificar rota√ß√£o para melhor visualiza√ß√£o
                y: rotY * 1.5, 
                z: rotZ * 0.8  // Reduzir um pouco a rota√ß√£o Z para evitar movimento excessivo
            };
        }

        // Inicializar Three.js
        function initThreeJS() {
            // Criar cena
            scene = new THREE.Scene();
            scene.background = null; // Fundo transparente
            
            // Adicionar luzes melhoradas
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            const pointLight1 = new THREE.PointLight(0x4CAF50, 0.6, 100);
            pointLight1.position.set(5, 5, 5);
            scene.add(pointLight1);
            
            const pointLight2 = new THREE.PointLight(0xFF5722, 0.4, 100);
            pointLight2.position.set(-5, -5, 5);
            scene.add(pointLight2);
            
            // Criar c√¢mera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 5);
            
            // Criar renderizador
            renderer = new THREE.WebGLRenderer({
                canvas: canvasElement,
                alpha: true, // Fundo transparente
                antialias: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            
            // Criar o objeto 3D
            objeto3D = criarObjeto3D();
            objeto3D.scale.set(0.5, 0.5, 0.5); // Escala base
            scene.add(objeto3D);
            
            // Configurar eventos de redimensionamento
            window.addEventListener('resize', onWindowResize);
            
            updateLoadingStatus("Three.js inicializado com sucesso!");
        }

        // Manipular redimensionamento da janela
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Configurar MediaPipe Hands
        function setupMediaPipe() {
            const hands = new Hands({
                locateFile: (file) => {
                    return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
                }
            });
            
            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.7,
                minTrackingConfidence: 0.7
            });
            
            hands.onResults(onHandResults);
            
            // Iniciar a c√¢mera
            const cameraInstance = new Camera(videoElement, {
                onFrame: async () => {
                    await hands.send({image: videoElement});
                },
                width: videoWidth,
                height: videoHeight
            });
            
            cameraInstance.start()
                .then(() => {
                    updateLoadingStatus("C√¢mera iniciada com sucesso!");
                })
                .catch(error => {
                    updateLoadingStatus("Erro ao iniciar a c√¢mera: " + error, true);
                });
            
            return hands;
        }

        // Processar resultados do MediaPipe Hands
        function onHandResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                handDetected = true;
                
                // Usar o centro da palma (landmark 9 - base do dedo m√©dio)
                const palmCenter = landmarks[9];
                
                // Converter para coordenadas do mundo 3D
                const worldPos = convertHandToWorld(palmCenter.x, palmCenter.y, palmCenter.z);
                
                // Aplicar suaviza√ß√£o para posi√ß√£o
                handPosition.x = handPosition.x * smoothingFactor + worldPos.x * (1 - smoothingFactor);
                handPosition.y = handPosition.y * smoothingFactor + worldPos.y * (1 - smoothingFactor);
                handPosition.z = handPosition.z * smoothingFactor + worldPos.z * (1 - smoothingFactor);
                
                // Calcular e aplicar orienta√ß√£o da m√£o
                const orientation = calculateHandOrientation(landmarks);
                handRotation.x = handRotation.x * rotationSmoothingFactor + orientation.x * (1 - rotationSmoothingFactor);
                handRotation.y = handRotation.y * rotationSmoothingFactor + orientation.y * (1 - rotationSmoothingFactor);
                handRotation.z = handRotation.z * rotationSmoothingFactor + orientation.z * (1 - rotationSmoothingFactor);
                
                // Calcular e aplicar escala baseada no tamanho da m√£o
                const newScale = calculateHandSize(landmarks);
                handScale = handScale * scaleSmoothingFactor + newScale * (1 - scaleSmoothingFactor);
                
                // Atualizar informa√ß√µes de debug
                handStatus.textContent = "M√£o: Detectada";
                positionInfo.innerHTML = `X: ${handPosition.x.toFixed(2)}<br>Y: ${handPosition.y.toFixed(2)}<br>Z: ${handPosition.z.toFixed(2)}`;
                rotationInfo.innerHTML = `RX: ${(handRotation.x * 180/Math.PI).toFixed(1)}¬∞<br>RY: ${(handRotation.y * 180/Math.PI).toFixed(1)}¬∞<br>RZ: ${(handRotation.z * 180/Math.PI).toFixed(1)}¬∞`;
                scaleInfo.textContent = `Tamanho: ${(handScale * 100).toFixed(1)}%`;
                confidenceInfo.textContent = `${(results.multiHandedness[0].score * 100).toFixed(1)}%`;
                
            } else {
                handDetected = false;
                handStatus.textContent = "M√£o: N√£o detectada";
                positionInfo.innerHTML = "X: --<br>Y: --<br>Z: --";
                rotationInfo.innerHTML = "RX: --<br>RY: --<br>RZ: --";
                scaleInfo.textContent = "Tamanho: --";
                confidenceInfo.textContent = "--";
            }
        }

        // Anima√ß√£o
        function animate() {
            requestAnimationFrame(animate);
            
            if (handDetected && objeto3D) {
                // Posicionar o objeto exatamente na posi√ß√£o da m√£o
                objeto3D.position.set(handPosition.x, handPosition.y, handPosition.z);
                
                // Aplicar rota√ß√£o baseada na orienta√ß√£o da m√£o
                objeto3D.rotation.set(handRotation.x, handRotation.y, handRotation.z);
                
                // Aplicar escala din√¢mica baseada no tamanho da m√£o
                const finalScale = handScale * 0.8; // Escala base ajustada
                objeto3D.scale.set(finalScale, finalScale, finalScale);
                
                // Manter o objeto vis√≠vel
                objeto3D.visible = true;
                
                // Executar anima√ß√£o interna do objeto
                if (objeto3D.userData.animate) {
                    objeto3D.userData.animate();
                }
            } else {
                // Esconder o objeto quando a m√£o n√£o for detectada
                if (objeto3D) {
                    objeto3D.visible = false;
                }
            }
            
            renderer.render(scene, camera);
        }

        // Inicializar a aplica√ß√£o
        async function initApp() {
            try {
                updateLoadingStatus("Inicializando Three.js...");
                initThreeJS();
                
                updateLoadingStatus("Configurando MediaPipe Hands...");
                setupMediaPipe();
                
                updateLoadingStatus("Iniciando anima√ß√£o...");
                animate();
                
                // Esconder tela de carregamento ap√≥s 3 segundos
                setTimeout(() => {
                    loadingElement.style.opacity = '0';
                    setTimeout(() => {
                        loadingElement.style.display = 'none';
                    }, 500);
                }, 3000);
            } catch (error) {
                updateLoadingStatus("Erro na inicializa√ß√£o: " + error, true);
            }
        }

        // Iniciar quando o documento estiver carregado
        document.addEventListener('DOMContentLoaded', initApp);
    </script>
</body>
</html>

